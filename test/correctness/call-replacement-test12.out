******************************* SparseAccelerator ******************************
Signature:
    (x::Array{Float64,1}, A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}, b::Array{Float64,1}, M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}, tol::Float64, maxiter::Int64)

AST:
    $(Expr(:lambda, Any[:x,:A,:b,:M,:tol,:maxiter], Any[Any[Any[:x,Array{Float64,1},18],Any[:A,Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},0],Any[:b,Array{Float64,1},0],Any[:M,Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},0],Any[:tol,Float64,0],Any[:maxiter,Int64,0],Any[:normr0,Float64,18],Any[:old_rz,Float64,18],Any[:Ap,Array{Float64,1},18],Any[:alpha,Float64,18],Any[:r,Array{Float64,1},2],Any[:rel_err,Any,2],Any[:z,Array{Float64,1},2],Any[:rz,Float64,2],Any[:beta,Float64,18],Any[:p,Array{Float64,1},2],Any[:k,Int64,2]],Any[],Any[],Any[]], :(begin  # /media/sf_VBoxVMShared/SparseAccelerator/cleanup/test/correctness/./pcg.jl, line 4:
            NewvarNode(:old_rz)
            NewvarNode(:Ap)
            NewvarNode(:alpha)
            NewvarNode(:beta)
            r = b::Array{Float64,1} - A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} * x::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 5:
            normr0 = (Main.norm)(r::Array{Float64,1})::Float64 # line 6:
            rel_err = 1 # line 7:
            z = (top(typeassert))((top(convert))((top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}},M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}  r::Array{Float64,1}),(top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}})::Array{Float64,1} # line 8:
            p = (Main.copy)(z::Array{Float64,1})::Array{Float64,1} # line 9:
            rz = (Main.dot)(r::Array{Float64,1},z::Array{Float64,1})::Float64 # line 10:
            k = 1 # line 11:
            NewvarNode(:old_rz)
            NewvarNode(:Ap)
            NewvarNode(:alpha)
            NewvarNode(:beta)
            unless k::Int64 <= maxiter::Int64::Bool goto 3
            0:  # line 12:
            old_rz = rz::Float64 # line 13:
            Ap = A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} * p::Array{Float64,1}::Array{Float64,1} # line 14:
            alpha = old_rz::Float64 / (Main.dot)(p::Array{Float64,1},Ap::Array{Float64,1})::Float64::Float64 # line 15:
            x = x::Array{Float64,1} + alpha::Float64 * p::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 16:
            r = r::Array{Float64,1} - alpha::Float64 * Ap::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 17:
            rel_err = (Main.norm)(r::Array{Float64,1})::Float64 / normr0::Float64::Float64 # line 18:
            unless rel_err::Float64 < tol::Float64::Bool goto 1 # line 19:
            goto 3
            1:  # line 21:
            z = (top(typeassert))((top(convert))((top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}},M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}  r::Array{Float64,1}),(top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}})::Array{Float64,1} # line 22:
            rz = (Main.dot)(r::Array{Float64,1},z::Array{Float64,1})::Float64 # line 23:
            beta = rz::Float64 / old_rz::Float64::Float64 # line 24:
            p = z::Array{Float64,1} + beta::Float64 * p::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 25:
            k = k::Int64 + 1::Int64
            2: 
            unless (top(!))(k::Int64 <= maxiter::Int64::Bool)::Bool goto 0
            3:  # line 27:
            return (top(tuple))(x::Array{Float64,1},k::Int64,rel_err::Union{Float64,Int64})::Tuple{Array{Float64,1},Int64,Union{Float64,Int64}}
        end::Tuple{Array{Float64,1},Int64,Union{Float64,Int64}})))

Function body showing structures:
    Expr lambda [Any]
         # /media/sf_VBoxVMShared/SparseAccelerator/cleanup/test/correctness/./pcg.jl, line 4:
        NewvarNode(:old_rz) [NewvarNode]
    
        NewvarNode(:Ap) [NewvarNode]
    
        NewvarNode(:alpha) [NewvarNode]
    
        NewvarNode(:beta) [NewvarNode]
    
        // r = b::Array{Float64,1} - A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} * x::Array{Float64,1}::Array{Float64,1}::Array{Float64,1}
        Expr = [Any]
            r [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                Main.- [GlobalRef]
                b::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                Expr call [Array{Float64,1}]
                    Main.* [GlobalRef]
                    A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
                    x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 5: [LineNumberNode]
    
        // normr0 = (Main.norm)(r::Array{Float64,1})::Float64
        Expr = [Any]
            normr0 [Symbol] [Float64]
            Expr call [Float64]
                Main.norm [GlobalRef]
                r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 6: [LineNumberNode]
    
        // rel_err = 1
        Expr = [Any]
            rel_err [Symbol] [Any]
            1 [Int64]
    
         # line 7: [LineNumberNode]
    
        // z = (top(typeassert))((top(convert))((top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}},M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}  r::Array{Float64,1}),(top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}})::Array{Float64,1}
        Expr = [Any]
            z [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                top(typeassert) [TopNode]
                Expr call [Any]
                    top(convert) [TopNode]
                    Expr call [Type{Array{Float64,1}}]
                        top(apply_type) [TopNode]
                        Main.Vector [GlobalRef]
                        Main.Float64 [GlobalRef]
                    Expr call [Any]
                        Main. [GlobalRef]
                        M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
                        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                Expr call [Type{Array{Float64,1}}]
                    top(apply_type) [TopNode]
                    Main.Vector [GlobalRef]
                    Main.Float64 [GlobalRef]
    
         # line 8: [LineNumberNode]
    
        // p = (Main.copy)(z::Array{Float64,1})::Array{Float64,1}
        Expr = [Any]
            p [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                Main.copy [GlobalRef]
                z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 9: [LineNumberNode]
    
        // rz = (Main.dot)(r::Array{Float64,1},z::Array{Float64,1})::Float64
        Expr = [Any]
            rz [Symbol] [Float64]
            Expr call [Float64]
                Main.dot [GlobalRef]
                r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 10: [LineNumberNode]
    
        // k = 1
        Expr = [Any]
            k [Symbol] [Int64]
            1 [Int64]
    
         # line 11: [LineNumberNode]
    
        NewvarNode(:old_rz) [NewvarNode]
    
        NewvarNode(:Ap) [NewvarNode]
    
        NewvarNode(:alpha) [NewvarNode]
    
        NewvarNode(:beta) [NewvarNode]
    
        // unless k::Int64 <= maxiter::Int64::Bool goto 3
        Expr gotoifnot [Any]
            Expr call [Bool]
                Main.<= [GlobalRef]
                k::Int64 [SymbolNode] [Int64]
                maxiter::Int64 [SymbolNode] [Int64]
            3 [Int64]
    
        0:  [LabelNode]
    
         # line 12: [LineNumberNode]
    
        // old_rz = rz::Float64
        Expr = [Any]
            old_rz [Symbol] [Float64]
            rz::Float64 [SymbolNode] [Float64]
    
         # line 13: [LineNumberNode]
    
        // Ap = A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} * p::Array{Float64,1}::Array{Float64,1}
        Expr = [Any]
            Ap [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                Main.* [GlobalRef]
                A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
                p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 14: [LineNumberNode]
    
        // alpha = old_rz::Float64 / (Main.dot)(p::Array{Float64,1},Ap::Array{Float64,1})::Float64::Float64
        Expr = [Any]
            alpha [Symbol] [Float64]
            Expr call [Float64]
                Main./ [GlobalRef]
                old_rz::Float64 [SymbolNode] [Float64]
                Expr call [Float64]
                    Main.dot [GlobalRef]
                    p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                    Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 15: [LineNumberNode]
    
        // x = x::Array{Float64,1} + alpha::Float64 * p::Array{Float64,1}::Array{Float64,1}::Array{Float64,1}
        Expr = [Any]
            x [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                Main.+ [GlobalRef]
                x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                Expr call [Array{Float64,1}]
                    Main.* [GlobalRef]
                    alpha::Float64 [SymbolNode] [Float64]
                    p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 16: [LineNumberNode]
    
        // r = r::Array{Float64,1} - alpha::Float64 * Ap::Array{Float64,1}::Array{Float64,1}::Array{Float64,1}
        Expr = [Any]
            r [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                Main.- [GlobalRef]
                r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                Expr call [Array{Float64,1}]
                    Main.* [GlobalRef]
                    alpha::Float64 [SymbolNode] [Float64]
                    Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 17: [LineNumberNode]
    
        // rel_err = (Main.norm)(r::Array{Float64,1})::Float64 / normr0::Float64::Float64
        Expr = [Any]
            rel_err [Symbol] [Any]
            Expr call [Float64]
                Main./ [GlobalRef]
                Expr call [Float64]
                    Main.norm [GlobalRef]
                    r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                normr0::Float64 [SymbolNode] [Float64]
    
         # line 18: [LineNumberNode]
    
        // unless rel_err::Float64 < tol::Float64::Bool goto 1
        Expr gotoifnot [Any]
            Expr call [Bool]
                Main.< [GlobalRef]
                rel_err::Float64 [SymbolNode] [Float64]
                tol::Float64 [SymbolNode] [Float64]
            1 [Int64]
    
         # line 19: [LineNumberNode]
    
        // goto 3
        goto 3 [GotoNode]
    
        1:  [LabelNode]
    
         # line 21: [LineNumberNode]
    
        // z = (top(typeassert))((top(convert))((top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}},M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}  r::Array{Float64,1}),(top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}})::Array{Float64,1}
        Expr = [Any]
            z [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                top(typeassert) [TopNode]
                Expr call [Any]
                    top(convert) [TopNode]
                    Expr call [Type{Array{Float64,1}}]
                        top(apply_type) [TopNode]
                        Main.Vector [GlobalRef]
                        Main.Float64 [GlobalRef]
                    Expr call [Any]
                        Main. [GlobalRef]
                        M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
                        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                Expr call [Type{Array{Float64,1}}]
                    top(apply_type) [TopNode]
                    Main.Vector [GlobalRef]
                    Main.Float64 [GlobalRef]
    
         # line 22: [LineNumberNode]
    
        // rz = (Main.dot)(r::Array{Float64,1},z::Array{Float64,1})::Float64
        Expr = [Any]
            rz [Symbol] [Float64]
            Expr call [Float64]
                Main.dot [GlobalRef]
                r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 23: [LineNumberNode]
    
        // beta = rz::Float64 / old_rz::Float64::Float64
        Expr = [Any]
            beta [Symbol] [Float64]
            Expr call [Float64]
                Main./ [GlobalRef]
                rz::Float64 [SymbolNode] [Float64]
                old_rz::Float64 [SymbolNode] [Float64]
    
         # line 24: [LineNumberNode]
    
        // p = z::Array{Float64,1} + beta::Float64 * p::Array{Float64,1}::Array{Float64,1}::Array{Float64,1}
        Expr = [Any]
            p [Symbol] [Array{Float64,1}]
            Expr call [Array{Float64,1}]
                Main.+ [GlobalRef]
                z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                Expr call [Array{Float64,1}]
                    Main.* [GlobalRef]
                    beta::Float64 [SymbolNode] [Float64]
                    p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
    
         # line 25: [LineNumberNode]
    
        // k = k::Int64 + 1::Int64
        Expr = [Any]
            k [Symbol] [Int64]
            Expr call [Int64]
                Main.+ [GlobalRef]
                k::Int64 [SymbolNode] [Int64]
                1 [Int64]
    
        2:  [LabelNode]
    
        // unless (top(!))(k::Int64 <= maxiter::Int64::Bool)::Bool goto 0
        Expr gotoifnot [Any]
            Expr call [Bool]
                top(!) [TopNode]
                Expr call [Bool]
                    Main.<= [GlobalRef]
                    k::Int64 [SymbolNode] [Int64]
                    maxiter::Int64 [SymbolNode] [Int64]
            0 [Int64]
    
        3:  [LabelNode]
    
         # line 27: [LineNumberNode]
    
        // return (top(tuple))(x::Array{Float64,1},k::Int64,rel_err::Union{Float64,Int64})::Tuple{Array{Float64,1},Int64,Union{Float64,Int64}}
        Expr return [Any]
            Expr call [Tuple{Array{Float64,1},Int64,Union{Float64,Int64}}]
                top(tuple) [TopNode]
                x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
                k::Int64 [SymbolNode] [Int64]
                rel_err::Union{Float64,Int64} [SymbolNode] [Union{Float64,Int64}]
    

Replace
    Expr call [Array{Float64,1}]
        Main.* [GlobalRef]
        A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Array{Float64,1}]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :SpMV [QuoteNode]
        A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    SpMV_pattern1
    (:call,:(Main.*),Base.SparseMatrix.SparseMatrixCSC{Tv,Ti<:Integer},Array{T,1})
    (:NO_SUB_PATTERNS,)
    (:call,:((top(getfield))(SparseAccelerator,:SpMV)),:arg2,:arg3)
Replace
    Expr call [Float64]
        Main.dot [GlobalRef]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Float64]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :Dot [QuoteNode]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    dot_pattern1
    (:call,:(Main.dot),Array{T,1},Array{T,1})
    (:NO_SUB_PATTERNS,)
    (:call,:((top(getfield))(SparseAccelerator,:Dot)),:arg2,:arg3)
Replace
    Expr call [Array{Float64,1}]
        Main.+ [GlobalRef]
        x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        Expr call [Array{Float64,1}]
            Main.* [GlobalRef]
            alpha::Float64 [SymbolNode] [Float64]
            p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Array{Float64,1}]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :WAXPBY [QuoteNode]
        1 [Int64]
        x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        alpha::Float64 [SymbolNode] [Float64]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    WAXPBY_pattern1
    (:call,:(Main.+),Array{T,1},Array{T,1})
    (nothing,nothing,nothing,SparseAccelerator.ExprPattern("number_times_vector_pattern",(:call,:(Main.*),Number,Array{T,1}),(:NO_SUB_PATTERNS,),(:NO_CHANGE,)))
    (:call,:((top(getfield))(SparseAccelerator,:WAXPBY)),1,:arg2,:aarg32,:aarg33)
Replace
    Expr = [Any]
        x [Symbol] [Array{Float64,1}]
        Expr call [Array{Float64,1}]
            Expr call [Function]
                top(getfield) [TopNode]
                SparseAccelerator [Symbol] [Void]
                :WAXPBY [QuoteNode]
            1 [Int64]
            x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
            alpha::Float64 [SymbolNode] [Float64]
            p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Any]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :WAXPBY! [QuoteNode]
        x [Symbol] [Array{Float64,1}]
        1 [Int64]
        x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        alpha::Float64 [SymbolNode] [Float64]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    WAXPBY!_pattern1
    (:(=),Array{T,1},Array{T,1})
    (nothing,nothing,SparseAccelerator.ExprPattern("WAXPBY_4_parameters_pattern",(:call,:((top(getfield))(SparseAccelerator,:WAXPBY)),Number,Array{T,1},Number,Array{T,1}),(:NO_SUB_PATTERNS,),(:NO_CHANGE,)))
    (:call,:((top(getfield))(SparseAccelerator,:WAXPBY!)),:arg1,:aarg22,:aarg23,:aarg24,:aarg25)
Replace
    Expr call [Array{Float64,1}]
        Main.- [GlobalRef]
        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        Expr call [Array{Float64,1}]
            Main.* [GlobalRef]
            alpha::Float64 [SymbolNode] [Float64]
            Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Array{Float64,1}]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :WAXPBY [QuoteNode]
        1 [Int64]
        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        Expr call [Float64]
            - [Symbol] [Void]
            alpha::Float64 [SymbolNode] [Float64]
        Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    WAXPBY_pattern2
    (:call,:(Main.-),Array{T,1},Array{T,1})
    (nothing,nothing,nothing,SparseAccelerator.ExprPattern("number_times_vector_pattern",(:call,:(Main.*),Number,Array{T,1}),(:NO_SUB_PATTERNS,),(:NO_CHANGE,)))
    (:call,:((top(getfield))(SparseAccelerator,:WAXPBY)),1,:arg2,:naarg32,:aarg33)
Replace
    Expr = [Any]
        r [Symbol] [Array{Float64,1}]
        Expr call [Array{Float64,1}]
            Expr call [Function]
                top(getfield) [TopNode]
                SparseAccelerator [Symbol] [Void]
                :WAXPBY [QuoteNode]
            1 [Int64]
            r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
            Expr call [Float64]
                - [Symbol] [Void]
                alpha::Float64 [SymbolNode] [Float64]
            Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Any]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :WAXPBY! [QuoteNode]
        r [Symbol] [Array{Float64,1}]
        1 [Int64]
        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        Expr call [Float64]
            - [Symbol] [Void]
            alpha::Float64 [SymbolNode] [Float64]
        Ap::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    WAXPBY!_pattern1
    (:(=),Array{T,1},Array{T,1})
    (nothing,nothing,SparseAccelerator.ExprPattern("WAXPBY_4_parameters_pattern",(:call,:((top(getfield))(SparseAccelerator,:WAXPBY)),Number,Array{T,1},Number,Array{T,1}),(:NO_SUB_PATTERNS,),(:NO_CHANGE,)))
    (:call,:((top(getfield))(SparseAccelerator,:WAXPBY!)),:arg1,:aarg22,:aarg23,:aarg24,:aarg25)
Replace
    Expr call [Array{Float64,1}]
        Main.* [GlobalRef]
        A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
        x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Array{Float64,1}]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :SpMV [QuoteNode]
        A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
        x::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    SpMV_pattern1
    (:call,:(Main.*),Base.SparseMatrix.SparseMatrixCSC{Tv,Ti<:Integer},Array{T,1})
    (:NO_SUB_PATTERNS,)
    (:call,:((top(getfield))(SparseAccelerator,:SpMV)),:arg2,:arg3)
Replace
    Expr call [Float64]
        Main.dot [GlobalRef]
        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Float64]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :Dot [QuoteNode]
        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    dot_pattern1
    (:call,:(Main.dot),Array{T,1},Array{T,1})
    (:NO_SUB_PATTERNS,)
    (:call,:((top(getfield))(SparseAccelerator,:Dot)),:arg2,:arg3)
Replace
    Expr call [Float64]
        Main.dot [GlobalRef]
        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Float64]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :Dot [QuoteNode]
        r::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    dot_pattern1
    (:call,:(Main.dot),Array{T,1},Array{T,1})
    (:NO_SUB_PATTERNS,)
    (:call,:((top(getfield))(SparseAccelerator,:Dot)),:arg2,:arg3)
Replace
    Expr call [Array{Float64,1}]
        Main.+ [GlobalRef]
        z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        Expr call [Array{Float64,1}]
            Main.* [GlobalRef]
            beta::Float64 [SymbolNode] [Float64]
            p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Array{Float64,1}]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :WAXPBY [QuoteNode]
        1 [Int64]
        z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        beta::Float64 [SymbolNode] [Float64]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    WAXPBY_pattern1
    (:call,:(Main.+),Array{T,1},Array{T,1})
    (nothing,nothing,nothing,SparseAccelerator.ExprPattern("number_times_vector_pattern",(:call,:(Main.*),Number,Array{T,1}),(:NO_SUB_PATTERNS,),(:NO_CHANGE,)))
    (:call,:((top(getfield))(SparseAccelerator,:WAXPBY)),1,:arg2,:aarg32,:aarg33)
Replace
    Expr = [Any]
        p [Symbol] [Array{Float64,1}]
        Expr call [Array{Float64,1}]
            Expr call [Function]
                top(getfield) [TopNode]
                SparseAccelerator [Symbol] [Void]
                :WAXPBY [QuoteNode]
            1 [Int64]
            z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
            beta::Float64 [SymbolNode] [Float64]
            p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Any]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :WAXPBY! [QuoteNode]
        p [Symbol] [Array{Float64,1}]
        1 [Int64]
        z::Array{Float64,1} [SymbolNode] [Array{Float64,1}]
        beta::Float64 [SymbolNode] [Float64]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

according to pattern
    WAXPBY!_pattern1
    (:(=),Array{T,1},Array{T,1})
    (nothing,nothing,SparseAccelerator.ExprPattern("WAXPBY_4_parameters_pattern",(:call,:((top(getfield))(SparseAccelerator,:WAXPBY)),Number,Array{T,1},Number,Array{T,1}),(:NO_SUB_PATTERNS,),(:NO_CHANGE,)))
    (:call,:((top(getfield))(SparseAccelerator,:WAXPBY!)),:arg1,:aarg22,:aarg23,:aarg24,:aarg25)

New AST:
    $(Expr(:lambda, Any[:x,:A,:b,:M,:tol,:maxiter], Any[Any[Any[:x,Array{Float64,1},18],Any[:A,Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},0],Any[:b,Array{Float64,1},0],Any[:M,Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},0],Any[:tol,Float64,0],Any[:maxiter,Int64,0],Any[:normr0,Float64,18],Any[:old_rz,Float64,18],Any[:Ap,Array{Float64,1},18],Any[:alpha,Float64,18],Any[:r,Array{Float64,1},2],Any[:rel_err,Any,2],Any[:z,Array{Float64,1},2],Any[:rz,Float64,2],Any[:beta,Float64,18],Any[:p,Array{Float64,1},2],Any[:k,Int64,2]],Any[],Any[],Any[]], :(begin  # /media/sf_VBoxVMShared/SparseAccelerator/cleanup/test/correctness/./pcg.jl, line 4:
            NewvarNode(:old_rz)
            NewvarNode(:Ap)
            NewvarNode(:alpha)
            NewvarNode(:beta)
            r = b::Array{Float64,1} - ((top(getfield))(SparseAccelerator,:SpMV))(A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},x::Array{Float64,1})::Array{Float64,1}::Array{Float64,1} # line 5:
            normr0 = (Main.norm)(r::Array{Float64,1})::Float64 # line 6:
            rel_err = 1 # line 7:
            z = (top(typeassert))((top(convert))((top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}},M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}  r::Array{Float64,1}),(top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}})::Array{Float64,1} # line 8:
            p = (Main.copy)(z::Array{Float64,1})::Array{Float64,1} # line 9:
            rz = ((top(getfield))(SparseAccelerator,:Dot))(r::Array{Float64,1},z::Array{Float64,1})::Float64 # line 10:
            k = 1 # line 11:
            NewvarNode(:old_rz)
            NewvarNode(:Ap)
            NewvarNode(:alpha)
            NewvarNode(:beta)
            unless k::Int64 <= maxiter::Int64::Bool goto 3
            0:  # line 12:
            old_rz = rz::Float64 # line 13:
            Ap = ((top(getfield))(SparseAccelerator,:SpMV))(A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},p::Array{Float64,1})::Array{Float64,1} # line 14:
            alpha = old_rz::Float64 / ((top(getfield))(SparseAccelerator,:Dot))(p::Array{Float64,1},Ap::Array{Float64,1})::Float64::Float64 # line 15:
            ((top(getfield))(SparseAccelerator,:WAXPBY!))(x,1,x::Array{Float64,1},alpha::Float64,p::Array{Float64,1}) # line 16:
            ((top(getfield))(SparseAccelerator,:WAXPBY!))(r,1,r::Array{Float64,1},-alpha::Float64::Float64,Ap::Array{Float64,1}) # line 17:
            rel_err = (Main.norm)(r::Array{Float64,1})::Float64 / normr0::Float64::Float64 # line 18:
            unless rel_err::Float64 < tol::Float64::Bool goto 1 # line 19:
            goto 3
            1:  # line 21:
            z = (top(typeassert))((top(convert))((top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}},M::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}  r::Array{Float64,1}),(top(apply_type))(Main.Vector,Main.Float64)::Type{Array{Float64,1}})::Array{Float64,1} # line 22:
            rz = ((top(getfield))(SparseAccelerator,:Dot))(r::Array{Float64,1},z::Array{Float64,1})::Float64 # line 23:
            beta = rz::Float64 / old_rz::Float64::Float64 # line 24:
            ((top(getfield))(SparseAccelerator,:WAXPBY!))(p,1,z::Array{Float64,1},beta::Float64,p::Array{Float64,1}) # line 25:
            k = k::Int64 + 1::Int64
            2: 
            unless (top(!))(k::Int64 <= maxiter::Int64::Bool)::Bool goto 0
            3:  # line 27:
            return (top(tuple))(x::Array{Float64,1},k::Int64,rel_err::Union{Float64,Int64})::Tuple{Array{Float64,1},Int64,Union{Float64,Int64}}
        end::Tuple{Array{Float64,1},Int64,Union{Float64,Int64}})))
********************************************************************************
ERROR: LoadError: UndefVarError: DEFAULT_LIBRARY not defined
 in SpMV! at /media/sf_VBoxVMShared/SparseAccelerator/cleanup/test/correctness/../../src/lib-interface.jl:84
 in pcg_processFuncCall at /media/sf_VBoxVMShared/SparseAccelerator/cleanup/test/correctness/./pcg.jl:4
 in opt_calls_trampoline_pcg at /home/h/.julia/v0.4/CompilerTools/src/OptFramework.jl:490
 in include at ./boot.jl:254
 in include_from_node1 at ./loading.jl:197
 in process_options at ./client.jl:308
 in _start at ./client.jl:411
while loading /media/sf_VBoxVMShared/SparseAccelerator/cleanup/test/correctness/call-replacement-test12.jl, in expression starting on line 8
