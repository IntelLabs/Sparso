Matrix structures discovered:
    Union{GenSym,Symbol}[:L,:A]

Constant structures discovered:
    Union{GenSym,Symbol}[:L,:A]

Value symmetry discovered:

Structure symmetry discovered:

Constants discovered:
    Set(Union{GenSym,Symbol}[:tol,:A,:normr0,:L,:maxiter])

Single-defs discovered:
    Set(Union{GenSym,Symbol}[:beta,:rel_err,:k,:rz,:Ap,:z,:p,:U,:alpha,:old_rz,:r,:x])


According to pattern
    CS_SpMV_pattern1
    (:call,:(Main.*),Base.SparseMatrix.SparseMatrixCSC{Tv,Ti<:Integer},Array{T,1})
    (:NO_SUB_PATTERNS,)
    do_nothing
    (:call,:((top(getfield))(SparseAccelerator,:SpMV)),:arg2,:arg3)
    gather_context_sensitive_info
    NewFunctionKnob
    DeleteFunctionKnob
    (:arg2,)
    40
    (:arg2,:arg3)
replace
    Expr call [Array{Float64,1}]
        Main.* [GlobalRef]
        A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]

to
    Expr call [Array{Float64,1}]
        Expr call [Function]
            top(getfield) [TopNode]
            SparseAccelerator [Symbol] [Void]
            :SpMV [QuoteNode]
        A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} [SymbolNode] [Base.SparseMatrix.SparseMatrixCSC{Float64,Int32}]
        p::Array{Float64,1} [SymbolNode] [Array{Float64,1}]


Context-sensitive actions to take:
    Insert action:
        ##mknobA#8208 = (SparseAccelerator.new_matrix_knob)(A,true,true,false,false,false,false)
        ##fknob#8203 = (SparseAccelerator.new_function_knob)()
    outisde loop of BBs [0, 2, 1] before loop head BB 0
    
    Insert action:
        (SparseAccelerator.delete_matrix_knob)(##mknobA#8208)
        (SparseAccelerator.delete_function_knob)(##fknob#8203)
    on the edge BB 2 --> BB -5
    
    Insert action:
        (SparseAccelerator.delete_matrix_knob)(##mknobA#8208)
        (SparseAccelerator.delete_function_knob)(##fknob#8203)
    on the edge BB 0 --> BB -4
    
    Insert action:
        (SparseAccelerator.add_mknob_to_fknob)(##mknobA#8208,##fknob#8203)
    outisde loop of BBs [0, 2, 1] before loop head BB 0
    


New AST:
    $(Expr(:lambda, Any[:x,:A,:b,:tol,:maxiter], Any[Any[Any[:x,Array{Float64,1},18],Any[:A,Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},0],Any[:b,Array{Float64,1},0],Any[:tol,Float64,0],Any[:maxiter,Int64,0],Any[:L,Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},18],Any[:U,Any,18],Any[:M,Any,18],Any[:r,Array{Float64,1},2],Any[:normr0,Float64,18],Any[:rel_err,Any,2],Any[:z,Array{Float64,1},2],Any[:p,Array{Float64,1},2],Any[:rz,Float64,2],Any[:k,Int64,2],Any[:time1,Float64,18],Any[:old_rz,Float64,18],Any[:Ap,Array{Float64,1},18],Any[:alpha,Float64,18],Any[:beta,Float64,18]],Any[],Any[],Any[]], :(begin  # /media/sf_VBoxVMShared/SparseAccelerator/cleanup/test/correctness/./pcg-symgs.jl, line 2:
            NewvarNode(:old_rz)
            NewvarNode(:Ap)
            NewvarNode(:alpha)
            NewvarNode(:beta)
            L = (Main.tril)(A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32})::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} # line 3:
            U = (Main.spdiagm)(1 ./ (Main.diag)(A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32})::Array{Float64,1}::Array{Float64,1})::Base.SparseMatrix.SparseMatrixCSC{Tv,Ti<:Integer} * (Main.triu)(A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32})::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} # line 4:
            M = L::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} * U # line 5:
            r = b::Array{Float64,1} - A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32} * x::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 6:
            normr0 = (Main.norm)(r::Array{Float64,1})::Float64 # line 7:
            rel_err = 1 # line 9:
            z = (Main.copy)(r::Array{Float64,1})::Array{Float64,1} # line 10:
            ((top(getfield))(Base.SparseMatrix,:fwdTriSolve!)::F)(L::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},z::Array{Float64,1})::Array{Float64,1} # line 11:
            ((top(getfield))(Base.SparseMatrix,:bwdTriSolve!)::F)(U,z::Array{Float64,1})::Array{Float64,1} # line 13:
            p = (Main.copy)(z::Array{Float64,1})::Array{Float64,1} # line 14:
            rz = (Main.dot)(r::Array{Float64,1},z::Array{Float64,1})::Float64 # line 15:
            k = 1 # line 16:
            time1 = (Main.time)()::Float64 # line 17:
            NewvarNode(:old_rz)
            NewvarNode(:Ap)
            NewvarNode(:alpha)
            NewvarNode(:beta)
            unless k::Int64 <= maxiter::Int64::Bool goto 3
            4: 
            ##mknobA#8208 = (SparseAccelerator.new_matrix_knob)(A,true,true,false,false,false,false)
            ##fknob#8203 = (SparseAccelerator.new_function_knob)()
            (SparseAccelerator.add_mknob_to_fknob)(##mknobA#8208,##fknob#8203)
            goto 0
            0:  # line 18:
            old_rz = rz::Float64 # line 19:
            Ap = ((top(getfield))(SparseAccelerator,:SpMV))(A::Base.SparseMatrix.SparseMatrixCSC{Float64,Int32},p::Array{Float64,1},##fknob#8203)::Array{Float64,1} # line 20:
            alpha = old_rz::Float64 / (Main.dot)(p::Array{Float64,1},Ap::Array{Float64,1})::Float64::Float64 # line 21:
            x = x::Array{Float64,1} + alpha::Float64 * p::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 22:
            r = r::Array{Float64,1} - alpha::Float64 * Ap::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 23:
            rel_err = (Main.norm)(r::Array{Float64,1})::Float64 / normr0::Float64::Float64 # line 24:
            unless rel_err::Float64 < tol::Float64::Bool goto 1
            (SparseAccelerator.delete_matrix_knob)(##mknobA#8208)
            (SparseAccelerator.delete_function_knob)(##fknob#8203) # line 25:
            goto 3
            1:  # line 28:
            z = (Main.copy)(r::Array{Float64,1})::Array{Float64,1} # line 29:
            nothing # line 31:
            nothing # line 34:
            rz = (Main.dot)(r::Array{Float64,1},z::Array{Float64,1})::Float64 # line 35:
            beta = rz::Float64 / old_rz::Float64::Float64 # line 36:
            p = z::Array{Float64,1} + beta::Float64 * p::Array{Float64,1}::Array{Float64,1}::Array{Float64,1} # line 37:
            k = k::Int64 + 1::Int64
            2: 
            unless (top(!))(k::Int64 <= maxiter::Int64::Bool)::Bool goto 0
            (SparseAccelerator.delete_matrix_knob)(##mknobA#8208)
            (SparseAccelerator.delete_function_knob)(##fknob#8203)
            3:  # line 39:
            return (top(tuple))(x::Array{Float64,1},k::Int64,rel_err::Union{Float64,Int64})::Tuple{Array{Float64,1},Int64,Union{Float64,Int64}}
        end::Tuple{Array{Float64,1},Int64,Union{Float64,Int64}})))
********************************************************************************