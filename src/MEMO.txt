1. REORDERING: feasibility and correctness

Let function R represent reordering.
Let G be a graph representing a loop, where each node represents a computation
in the loop, or a live-in value to the loop. A special Phi node selects one of
the inputs dynamically so that for each input of each  computation, there is 
only one source for it. In other words, the graph is in SSA. 
Let LiveIn/Out be the values live into/out of L. 
Reordering transforms the loop as below:
    LiveIn = R(LiveIn)
    G
    Liveout = R'(LiveOut)  //R' is the reverse ordering.
We need to ensure the semantics remains the same. That is, the above is equivalent to
    G
To ensure the semantics is indeed preserved, the following condition is necessary
and sufficient: 
    R must be distributive over any computation in G.
Distributivity means that for a computation C whose inputs are i1, ..., in, 
    R(C(i1, ..., in)) = C(R(i1), ..., R(in))
For example, for the following computation where M is a matrix, and v is a vector: 
    M*v
Reordering 
    R(M*v) = P'*(M*v) = (P'*M*P)*(P'*v) = R(M)*R(v)
where P is a permutation matrix.

Reordering function R is defined as below, assuming the permutation matrix is P: 
    R(x) = P'*x*P  if x is a matrix // P' is conjugate transpose of P
         = P'*x    if x is a vector
         = x       if x is a number
         = error   no other kind of input is accepted.
         
The computations over which reordering is distributive: 
    M*M // R(M*M)=P'*(M*M)*P = (P'*M*P) *(P'*M*P)=R(M)*R(M)
    M+M // R(M+M)=P'*(M+M)*P = P'*M*P + P'*M*P = R(M)+R(M)
    M-M // similar
    M*v // as shown before
    M\v // M*x=v (i.e. x=M\v) is equivalent to (P'*M*P)*(P'x)=P'*v (i.e. R(x)=R(M)\R(v))
    dot(v,v) // R(dot(v,v))=R(v'*v)=v'*v= v'*P*P'*v = (P'*v)' * (P'*v) = dot(R(v), R(v))
    v+v // R(v+v)= P'*(v+v) = (P'*v) + (P'*v) = R(v)+R(v)
    v-v // similar
    n*M // n is a number. R(n*M)=P'*(n*M)*P=n*(P'*M*P)=n*R(M)
    n*v // R(n*v)= P'*(n*v)= n*(P'*v) = n*R(v)
    if(n) // Result of if is a boolean (0: false, 1:true). R(if(n))=R(n!=0)=(R(n)!=0)=if(R(n))
    else  // = if(n==0). Then similar to above
    any other expressions involving only numbers and returning only numbers:
        f(x:<Number):<Number ==> R(f(x)) == f(x) == f(R(x))
    
If reordering is distributive over every computation in the graph, then
R(G) is a graph in which every live-in value is reordered, while all the computation nodes remain
the same. Therefore, to preserve the semantics of the graph, we should reverse reorder the final
results of the graph, i.e., the live out values of the graph.

Over what computations R is NOT distributive: 
    Triangular solver // R would change the rows so that the input matrix is no longer triangular
    Unknown functions

For real field, 
    P' = P.'