\documentclass[pldi]{sigplanconf-pldi15}

%
% the following standard packages may be helpful, but are not required
%
\usepackage{SIunits}            % typset units correctly
\usepackage{courier}            % standard fixed width font
\usepackage[scaled]{helvet} % see www.ctan.org/get/macros/latex/required/psnfss/psnfss2e.pdf
\usepackage{url}                  % format URLs
\usepackage{listings}          % format code
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}   % print a hyperlinked DOI



\begin{document}

%
% any author declaration will be ignored  when using 'plid' option (for double blind review)
%

\title{Automatic Context-sensitive Input-aware Acceleration of Sparse Applications }

\maketitle
\begin{abstract}

Applications with huge sparse data structures have emerged as a new and increasingly important challenge for high-performance computing. Unlike the traditional dense linear algebra, their  performance is bound by memory bandwidth, and their parallelism is dependent on specific data. To speed them up, the most widely followed approach is manual optiomization by ``ninja'' experts, which is extremely time-consuming.

This paper proposes a co-designed compiler and library approach to automatically analyze and optimize sparse applications to achieve close-to-ninja performance. A compiler automatically analyzes an application, and passes context information to a library so that a library function can adjust its behavior optimally accross multiple loop iterations and multiple matrices, and collaborate with multiple functions, even though they are still uncoupled in design and implementation. 
   
We shows how to automatically reorder data. While there are many reordering algorithms, it has been an open question for more than 5 decades how to correctly insert the minimum amount of reordering and reverse reordering into an arbitrary piece of code. We prove this is an NP-complete problem, and propose a heuritisc algorithm to solve it. We show the key concepts of distributivity and inter-dependence, and their analyses. 

With ..., performance ...


\end{abstract}

\section{Introduction}
\section{A Motivating Example}
\section{Characteristics of Sparse Applications}
\section{Reordering}
\section{Context-sensitive Acceleration}
\section{Experiments}
\section{Related Works}
\section{Acknowledgements}

\bibliographystyle{abbrvnat}

% We recommend that you use BibTeX.  The inlined bibitems below are
% used to keep this template to a single file.
\begin{thebibliography}{}
\softraggedright
\end{thebibliography}

\end{document}
